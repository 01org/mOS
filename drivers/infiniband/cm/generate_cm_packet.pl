# $Id: generate_cm_packet.pl,v 1.3 2004/02/21 02:18:50 roland Exp $

use strict;

sub minpow2 {
  my $n = shift;
  my $r = 8;

  while ($r < $n) {
    $r *= 2;
  }

  return $r;
}

print "/* This file is automatically generated by generate_cm_packet.pl */\n";
print "/* Edits will probably be lost.                                  */\n";

my $packet_type;

print <<"CODE_TOP";

#ifndef W2K_OS
#include <asm/byteorder.h>
#endif

CODE_TOP

while (<>) {
  next if (/^\#/ or /^\s+$/);

  chomp;

  my @linelist = split;
  
  if (@linelist == 1) {
    $packet_type = $linelist[0];
    $packet_type =~ s/(\w+)/\u\L$1/g;
  } elsif (@linelist == 3) {
    my $size = &minpow2($linelist[2]);
    my $type = "uint" . "$size" . "_t";
    my $name = $linelist[0];
    $name =~ s/ (^|_) (\w) /\u$2/xg;

    SIZE_SWITCH: {
	if ($linelist[2] < 8) {
	  my $mask = sprintf "0x%02x", (1 << $linelist[2]) - 1;

	  my $byte;
	  my $offset;

	  if ($linelist[1] =~ / (\d+) \[ (\d+) \] /x) {
	    $byte = $1;
	    $offset = 8 - $2 - $linelist[2];
	  } else {
	    $byte = $linelist[1];
	    $offset = 8 - $linelist[2];
	  }

	  if ($offset == 0) {
	    print <<"END_DEF_SHORT";
static inline $type tsIbCm${packet_type}${name}Get(const tTS_IB_MAD packet) {
  return packet->payload[$byte] & $mask;
}

static inline void tsIbCm${packet_type}${name}Set(tTS_IB_MAD packet, ${type} value) {
  packet->payload[$byte] = value | (packet->payload[$byte] & ~$mask);
}

END_DEF_SHORT
	  } else {
	    print <<"END_DEF_SHORT_OFFSET";
static inline $type tsIbCm${packet_type}${name}Get(const tTS_IB_MAD packet) {
  return (packet->payload[$byte] >> $offset) & $mask;
}

static inline void tsIbCm${packet_type}${name}Set(tTS_IB_MAD packet, ${type} value) {
  packet->payload[$byte] = (value << $offset)
    | (packet->payload[$byte] & ~($mask << $offset));
}

END_DEF_SHORT_OFFSET
	  }

	  last SIZE_SWITCH;
	}

	if ($linelist[2] == 8) {
	  print <<"END_DEF8";
static inline $type tsIbCm${packet_type}${name}Get(const tTS_IB_MAD packet) {
  return packet->payload[$linelist[1]];
}

static inline void tsIbCm${packet_type}${name}Set(tTS_IB_MAD packet, ${type} value) {
  packet->payload[$linelist[1]] = value;
}

END_DEF8
	  last SIZE_SWITCH;
	}

	if ($linelist[2] == 16) {
	  die "16 bit quantity at an odd byte offset" if ($linelist[1] % 2);

	  print <<"END_DEF16";
static inline $type tsIbCm${packet_type}${name}Get(const tTS_IB_MAD packet) {
  return be16_to_cpu(*(($type *) &packet->payload[$linelist[1]]));
}

static inline void tsIbCm${packet_type}${name}Set(tTS_IB_MAD packet, ${type} value) {
  *(($type *) &packet->payload[$linelist[1]]) = cpu_to_be16(value);
}

END_DEF16
	  last SIZE_SWITCH;
	}

	if ($linelist[2] == 20) {
	  die "20 bit quantity not at word boundary" if ($linelist[1] % 4);

	  print <<"END_DEF20";
static inline $type tsIbCm${packet_type}${name}Get(const tTS_IB_MAD packet) {
  return be32_to_cpu(*(($type *) &packet->payload[$linelist[1]])) >> 12;
}

static inline void tsIbCm${packet_type}${name}Set(tTS_IB_MAD packet, ${type} value) {
  *(($type *) &packet->payload[$linelist[1]]) =
    cpu_to_be32((value << 12) | 
		(*(($type *) &packet->payload[$linelist[1]]) & 0x00000fff));
}

END_DEF20
	  last SIZE_SWITCH;
	}

	if ($linelist[2] == 24) {
	  die "24 bit quantity not at word boundary" if ($linelist[1] % 4);

	  print <<"END_DEF24";
static inline $type tsIbCm${packet_type}${name}Get(const tTS_IB_MAD packet) {
  return be32_to_cpu(*(($type *) &packet->payload[$linelist[1]])) >> 8;
}

static inline void tsIbCm${packet_type}${name}Set(tTS_IB_MAD packet, ${type} value) {
  *(($type *) &packet->payload[$linelist[1]]) =
    cpu_to_be32((value << 8) | packet->payload[$linelist[1] + 3]);
}

END_DEF24
	  last SIZE_SWITCH;
	}

	if ($linelist[2] == 32) {
	  die "32 bit quantity not at word boundary" if ($linelist[1] % 4);

	  print <<"END_DEF32";
static inline $type tsIbCm${packet_type}${name}Get(const tTS_IB_MAD packet) {
  return be32_to_cpu(*(($type *) &packet->payload[$linelist[1]]));
}

static inline void tsIbCm${packet_type}${name}Set(tTS_IB_MAD packet, ${type} value) {
  *(($type *) &packet->payload[$linelist[1]]) = cpu_to_be32(value);
}

END_DEF32
	  last SIZE_SWITCH;
	}

        if ($linelist[2] > 32) {
	  my $bytes = $linelist[2] / 8;

	  print <<"END_DEFPOINTER";
static inline void *tsIbCm${packet_type}${name}Get(const tTS_IB_MAD packet) {
  return &packet->payload[$linelist[1]];
}

static inline int tsIbCm${packet_type}${name}GetLength(void) {
  return $bytes;
}

END_DEFPOINTER

	  last SIZE_SWITCH;
	}

	die "unhandled data size $linelist[2]";
      }
    }
  }
