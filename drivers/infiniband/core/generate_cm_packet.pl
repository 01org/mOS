#  This software is available to you under a choice of one of two
#  licenses.  You may choose to be licensed under the terms of the GNU
#  General Public License (GPL) Version 2, available at
#  <http://www.fsf.org/copyleft/gpl.html>, or the OpenIB.org BSD
#  license, available in the LICENSE.TXT file accompanying this
#  software.  These details are also available at
#  <http://openib.org/license.html>.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
#  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
#  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
#  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#  SOFTWARE.
#
#  Copyright (c) 2004 Topspin Communications.  All rights reserved.
#
#  $Id: generate_cm_packet.pl 35 2004-04-09 05:34:32Z roland $

use strict;

sub minpow2 {
  my $n = shift;
  my $r = 8;

  while ($r < $n) {
    $r *= 2;
  }

  return $r;
}

print "/* This file is automatically generated by generate_cm_packet.pl */\n";
print "/* Edits will probably be lost.                                  */\n";

my $packet_type;

print <<"CODE_TOP";

#include <asm/byteorder.h>

CODE_TOP

while (<>) {
  next if (/^\#/ or /^\s+$/);

  chomp;

  my @linelist = split;
  
  if (@linelist == 1) {
    $packet_type = lc($linelist[0]);
  } elsif (@linelist == 3) {
    my $size = &minpow2($linelist[2]);
    my $type = "uint" . "$size" . "_t";
    my $name = lc($linelist[0]);

    SIZE_SWITCH: {
	if ($linelist[2] < 8) {
	  my $mask = sprintf "0x%02x", (1 << $linelist[2]) - 1;

	  my $byte;
	  my $offset;

	  if ($linelist[1] =~ / (\d+) \[ (\d+) \] /x) {
	    $byte = $1;
	    $offset = 8 - $2 - $linelist[2];
	  } else {
	    $byte = $linelist[1];
	    $offset = 8 - $linelist[2];
	  }

	  if ($offset == 0) {
	    print <<"END_DEF_SHORT";
static inline $type ib_cm_${packet_type}_${name}_get(const struct ib_mad *packet) {
	return packet->payload[$byte] & $mask;
}

static inline void ib_cm_${packet_type}_${name}_set(struct ib_mad *packet, ${type} value) {
	packet->payload[$byte] = value | (packet->payload[$byte] & ~$mask);
}

END_DEF_SHORT
	  } else {
	    print <<"END_DEF_SHORT_OFFSET";
static inline $type ib_cm_${packet_type}_${name}_get(const struct ib_mad *packet) {
	return (packet->payload[$byte] >> $offset) & $mask;
}

static inline void ib_cm_${packet_type}_${name}_set(struct ib_mad *packet, ${type} value) {
	packet->payload[$byte] = (value << $offset) |
			         (packet->payload[$byte] & ~($mask << $offset));
}

END_DEF_SHORT_OFFSET
	  }

	  last SIZE_SWITCH;
	}

	if ($linelist[2] == 8) {
	  print <<"END_DEF8";
static inline $type ib_cm_${packet_type}_${name}_get(const struct ib_mad *packet) {
	return packet->payload[$linelist[1]];
}

static inline void ib_cm_${packet_type}_${name}_set(struct ib_mad *packet, ${type} value) {
	packet->payload[$linelist[1]] = value;
}

END_DEF8
	  last SIZE_SWITCH;
	}

	if ($linelist[2] == 16) {
	  die "16 bit quantity at an odd byte offset" if ($linelist[1] % 2);

	  print <<"END_DEF16";
static inline $type ib_cm_${packet_type}_${name}_get(const struct ib_mad *packet) {
	return be16_to_cpu(*(($type *) &packet->payload[$linelist[1]]));
}

static inline void ib_cm_${packet_type}_${name}_set(struct ib_mad *packet, ${type} value) {
	*(($type *) &packet->payload[$linelist[1]]) = cpu_to_be16(value);
}

END_DEF16
	  last SIZE_SWITCH;
	}

	if ($linelist[2] == 20) {
	  die "20 bit quantity not at word boundary" if ($linelist[1] % 4);

	  print <<"END_DEF20";
static inline $type ib_cm_${packet_type}_${name}_get(const struct ib_mad *packet) {
	return be32_to_cpu(*(($type *) &packet->payload[$linelist[1]])) >> 12;
}

static inline void ib_cm_${packet_type}_${name}_set(struct ib_mad *packet, ${type} value) {
	*(($type *) &packet->payload[$linelist[1]]) =
		cpu_to_be32((value << 12) | 
			    (*(($type *) &packet->payload[$linelist[1]]) & 0x00000fff));
}

END_DEF20
	  last SIZE_SWITCH;
	}

	if ($linelist[2] == 24) {
	  die "24 bit quantity not at word boundary" if ($linelist[1] % 4);

	  print <<"END_DEF24";
static inline $type ib_cm_${packet_type}_${name}_get(const struct ib_mad *packet) {
	return be32_to_cpu(*(($type *) &packet->payload[$linelist[1]])) >> 8;
}

static inline void ib_cm_${packet_type}_${name}_set(struct ib_mad *packet, ${type} value) {
	*(($type *) &packet->payload[$linelist[1]]) =
		cpu_to_be32((value << 8) | packet->payload[$linelist[1] + 3]);
}

END_DEF24
	  last SIZE_SWITCH;
	}

	if ($linelist[2] == 32) {
	  die "32 bit quantity not at word boundary" if ($linelist[1] % 4);

	  print <<"END_DEF32";
static inline $type ib_cm_${packet_type}_${name}_get(const struct ib_mad *packet) {
	return be32_to_cpu(*(($type *) &packet->payload[$linelist[1]]));
}

static inline void ib_cm_${packet_type}_${name}_set(struct ib_mad *packet, ${type} value) {
	*(($type *) &packet->payload[$linelist[1]]) = cpu_to_be32(value);
}

END_DEF32
	  last SIZE_SWITCH;
	}

        if ($linelist[2] > 32) {
	  my $bytes = $linelist[2] / 8;

	  print <<"END_DEFPOINTER";
static inline void *ib_cm_${packet_type}_${name}_get(struct ib_mad *packet) {
	return &packet->payload[$linelist[1]];
}

static inline int ib_cm_${packet_type}_${name}_get_length(void) {
	return $bytes;
}

END_DEFPOINTER

	  last SIZE_SWITCH;
	}

	die "unhandled data size $linelist[2]";
      }
    }
  }
