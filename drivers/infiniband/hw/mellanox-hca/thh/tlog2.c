/*
  This software is available to you under a choice of one of two
  licenses.  You may choose to be licensed under the terms of the GNU
  General Public License (GPL) Version 2, available at
  <http://www.fsf.org/copyleft/gpl.html>, or the OpenIB.org BSD
  license, available in the LICENSE.TXT file accompanying this
  software.  These details are also available at
  <http://openib.org/license.html>.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  Copyright (c) 2004 Mellanox Technologies Ltd.  All rights reserved.
*/

#include <tlog2.h>

/************************************************************************
 * Divide and conquer to find the highest bits.
 * But when getting within 8 bits, just a lookup into a 
 * static constant table. This also serves a quick optimization
 * when x < 2^8 = 256. The constant table is set on compile time,
 * and was generated by the help of our Python friend.
 * Very efficient, if I may say so -- yotam
 */
unsigned int  floor_log2(u_int64_t x)
{
   enum { nLowBits = 8 };
   static const u_int64_t 
      highMask = ~(((u_int64_t)1 << nLowBits) - (u_int64_t)1);
   static const unsigned char  lowlog2[1<<nLowBits] =
   {
      0, /* special case (not -infinity) */
/*** The following Python script, generates the rest of the values:
#!/usr/bin/env python
import sys;
txt = '';
nLowBits = 8;
indent = '     ';
for p in range(0,nLowBits):
  n = 1 << p;
  elem = " %d," % p;
  nRows = int(n / 10);
  residue = n % 10;
  row = indent + 10 * elem + "\n";
  txt = txt + nRows * row;
  if residue:
     txt = txt + indent + residue * elem + "\n";
txt = txt[:-2] + "\n"; # delete last comma
sys.stdout.write(txt);
sys.exit(0);
***/
      0,
      1, 1,
      2, 2, 2, 2,
      3, 3, 3, 3, 3, 3, 3, 3,
      4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
      4, 4, 4, 4, 4, 4,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7
   };
   
   unsigned  step = 8*sizeof(u_int64_t);
   unsigned  p = 0;
   while (x & highMask)
   {
      u_int64_t   high;
      step >>= 1; /* /= 2 */
      high = (x >> step);
      if (high)
      {
         p |= step;
         x = high;
      }
      else
      {
         u_int64_t  mask = ((u_int64_t)1 << step) - 1;
         x &= mask;
      }
   }
      
   p |= lowlog2[x];
   return p;
} /* floor_log2 */


/************************************************************************/
unsigned int  ceil_log2(u_int64_t x)
{
   unsigned int  p = floor_log2(x);
   if (((u_int64_t)1 << p) < x)
   {
      p += 1;
   }
   return p;
} /* ceil_log2 */


/************************************************************************
 * Divide and conquer to find the lowest bit.
 * But when getting within 8 bits, just a lookup into a 
 * static constant table. This also serves a quick optimization
 * when x < 2^8 = 256. The constant table is set on compile time,
 * and was generated by the help of our Python friend.
 * Very efficient, if I may say so -- yotam
 */
unsigned int  lowest_bit(u_int64_t x)
{
   enum { nLowBits = 8 };
   static const u_int64_t one_64 = 1;
   static const u_int64_t lowMask = ((u_int64_t)1 << nLowBits) - (u_int64_t)1;
   static const unsigned char  lowest_bit8[1<<nLowBits] =
   {
      64, /* special case (not +infinity) - but actually unused */
/*** The following Python script, generates the rest of the values:
#!/usr/bin/env python
import sys;
nLowBits = 8;  N = 1<<nLowBits;
indent = '     ';
txt = indent;
for n in range(1,N):
  b = 0;
  while (1<<b & n) == 0:
    b = b + 1;
  if (n > 1) and (((1<<b) == n) or (n % 10 == 0)):
    txt = txt + "\n" + indent;
  txt = txt + (" %d," % b);
txt = txt[:-2] + "\n"; # delete last comma
sys.stdout.write(txt);
sys.exit(0);
***/
      0,
      1, 0,
      2, 0, 1, 0,
      3, 0,
      1, 0, 2, 0, 1, 0,
      4, 0, 1, 0,
      2, 0, 1, 0, 3, 0, 1, 0, 2, 0,
      1, 0,
      5, 0, 1, 0, 2, 0, 1, 0,
      3, 0, 1, 0, 2, 0, 1, 0, 4, 0,
      1, 0, 2, 0, 1, 0, 3, 0, 1, 0,
      2, 0, 1, 0,
      6, 0, 1, 0, 2, 0,
      1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
      4, 0, 1, 0, 2, 0, 1, 0, 3, 0,
      1, 0, 2, 0, 1, 0, 5, 0, 1, 0,
      2, 0, 1, 0, 3, 0, 1, 0, 2, 0,
      1, 0, 4, 0, 1, 0, 2, 0, 1, 0,
      3, 0, 1, 0, 2, 0, 1, 0,
      7, 0,
      1, 0, 2, 0, 1, 0, 3, 0, 1, 0,
      2, 0, 1, 0, 4, 0, 1, 0, 2, 0,
      1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
      5, 0, 1, 0, 2, 0, 1, 0, 3, 0,
      1, 0, 2, 0, 1, 0, 4, 0, 1, 0,
      2, 0, 1, 0, 3, 0, 1, 0, 2, 0,
      1, 0, 6, 0, 1, 0, 2, 0, 1, 0,
      3, 0, 1, 0, 2, 0, 1, 0, 4, 0,
      1, 0, 2, 0, 1, 0, 3, 0, 1, 0,
      2, 0, 1, 0, 5, 0, 1, 0, 2, 0,
      1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
      4, 0, 1, 0, 2, 0, 1, 0, 3, 0,
      1, 0, 2, 0, 1, 
   };
   
   unsigned  step = 8*sizeof(u_int64_t);
   unsigned  p = 64;
   if (x)
   {
      u_int64_t  xLow;
      p = 0;
      while ((xLow = (x & lowMask)) == 0)
      {
         u_int64_t   low;
         step >>= 1; /* /= 2 */
         low = x & ((one_64 << step) - 1);
         if (low)
         {
            x = low;
         }
         else
         {
            p |= step;
            x >>= step;
         }
      }
      p |= lowest_bit8[xLow];
   }
      
   return p;
} /* lowest_bit */


